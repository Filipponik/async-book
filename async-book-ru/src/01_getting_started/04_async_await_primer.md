# Пример `async`/`.await`

`async`/`.await` - инструменты для написания асинхронного кода встроенные в Rust, внешне похожие  на синхронный код. Ключевое слово `async` превращает исполняемый блок программы в конечный автомат, который реализует типаж `Future`. В синхронном методе вызов функции блокирует весь поток, в асинхронном же вызов через `Future` вернёт контроль над потоком, позволяя работать другим `Future`.

Добавим некоторые зависимости в файл `Cargo.toml`:

```toml
{{#include ../../examples/01_04_async_await_primer/Cargo.toml:9:10}}
```

При реализации асинхронной функции можно использовать такой синтаксис `async fn`:

```rust,edition2018
async fn do_something() { /* ... */ }
```

`async fn` возвращает значение, которые является `Future`. Что бы ни произошло, `Future` должна быть запущена в исполнителе.

```rust,edition2018
{{#include ../../examples/01_04_async_await_primer/src/lib.rs:hello_world}}
```

Внутри `async fn` можно использовать  `.await` для ожидания завершения другой реализации типажа `Future`, например, полученной из другой `async fn`). В отличие от `block_on`, `.await` не блокирует текущий поток, а асинхронно ожидает завершения футуры, позволяя другим задачам в потоке выполняться, пока эта футура не может быть исполнена.

Например, представим что у нас есть три асинхронные функции `async fn`: `learn_song`, `sing_song` и `dance`:

```rust,ignore
async fn learn_song() -> Song { ... }
async fn sing_song(song: Song) { ... }
async fn dance() { ... }
```

Одним из способов выполнения функций «разучить песню», «спеть» и «станцевать» будет блокировка потока исполнения на каждой из них индивидуально:

```rust,ignore
{{#include ../../examples/01_04_async_await_primer/src/lib.rs:block_on_each}}
```

В этом случае мы не достигаем наилучшей производительности - в один момент времени мы делаем только одно дело! Конечно, мы должны выучить песню до того, как петь её, но  мы можем танцевать одновременно с разучиванием песни и пением. Чтобы провернуть такой вариант, создадим две отдельные функции с `async fn`, которые могут запуститься параллельно:

```rust,ignore
{{#include ../../examples/01_04_async_await_primer/src/lib.rs:block_on_main}}
```

В этом примере, разучивание песни должно быть завершено до пения, но разучивание и пение могут завершиться одновременно с танцем. Если бы мы использовали `block_on(learn_song())` вместо `learn_song().await` внутри `learn_and_sing`, поток не смог бы делать ничего другого, пока работает `learn_song`. Из-за этого мы  одновременно с этим не можем танцевать.  С помощью ожидания `.await` футуры`learn_song`, мы разрешаем другим задачам захватить текущий поток исполнения, пока `learn_song` заблокирована. Это даёт возможность запускать нескольких футур в одном потоке параллельно.
